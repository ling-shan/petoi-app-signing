name: Sign, Notarize and Package Petoi Desktop App

on:
  workflow_dispatch:
    inputs:
      app_name:
        description: 'App name in DMG'
        required: true
        default: 'Petoi Desktop App.app'
      app_version:
        description: 'App version'
        required: true
        default: '1.2.5'

jobs:
  build-and-package:
    runs-on: macos-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Unzip Application
        run: unzip mac/Petoi\ Desktop\ App.zip -d mac/

      - name: Install create-dmg
        run: brew install create-dmg

      - name: Import Developer Certificates
        uses: apple-actions/import-codesign-certs@v2
        with:
          p12-file-base64: ${{ secrets.MAC_CERTIFICATE_DATA }}
          p12-password: ${{ secrets.MAC_CERTIFICATE_PASSWORD }}
      
      - name: Verify Installer Certificate
        run: |
          security find-identity -v | grep "Developer ID Application: Petoi LLC (H98JHTT3JH)" || {
            echo "Error: 未找到有效的签名证书"
            exit 1
          }

      - name: Code Sign (修复zip路径错误)
        run: |
          set -ex
          APP_PATH="mac/${{ github.event.inputs.app_name }}"
          RESOURCES_PATH="$APP_PATH/Contents/Resources"
          PYTHON_EXE_PATH="$APP_PATH/Contents/MacOS/python"
          # 关键修复：计算python37.zip的绝对路径
          PYTHON_ZIP_ABSOLUTE="$(cd "$(dirname "$RESOURCES_PATH/lib/python37.zip")" && pwd)/$(basename "$RESOURCES_PATH/lib/python37.zip")"
          ESPTOOL_PATH="$RESOURCES_PATH/resources/esptoolMac/esptool"

          # 优先签名Contents/MacOS下的python可执行文件（解决核心报错）
          if [ -f "$PYTHON_EXE_PATH" ]; then
            echo "签名Python可执行文件: $PYTHON_EXE_PATH"
            codesign --force --timestamp --options runtime \
              --sign "Developer ID Application: Petoi LLC (H98JHTT3JH)" \
              "$PYTHON_EXE_PATH"
          else
            echo "Error: 未找到Python可执行文件: $PYTHON_EXE_PATH"
            exit 1
          fi

          # 处理python37.zip内的.dylib文件
          if [ -f "$PYTHON_ZIP_ABSOLUTE" ]; then
            echo "处理压缩包: $PYTHON_ZIP_ABSOLUTE"
            TEMP_UNZIP=$(mktemp -d)
            unzip -q "$PYTHON_ZIP_ABSOLUTE" -d "$TEMP_UNZIP"
            
            # 签名解压后的所有.dylib文件
            find "$TEMP_UNZIP" -name "*.dylib" -type f -exec \
              codesign --force --timestamp --options runtime \
              --sign "Developer ID Application: Petoi LLC (H98JHTT3JH)" {} \;
            
            # 关键修复：删除原文件并使用绝对路径重新压缩
            rm -f "$PYTHON_ZIP_ABSOLUTE"  # 确保原文件被删除，避免占用
            cd "$TEMP_UNZIP" && zip -q -r "$PYTHON_ZIP_ABSOLUTE" ./*  # 使用绝对路径输出
            cd -  # 返回原工作目录
            rm -rf "$TEMP_UNZIP"  # 清理临时文件
          else
            echo "Error: 未找到python37.zip: $PYTHON_ZIP_ABSOLUTE"
            exit 1
          fi

          # 签名esptool（确保硬化运行时）
          if [ -f "$ESPTOOL_PATH" ]; then
            echo "签名esptool: $ESPTOOL_PATH"
            codesign --force --timestamp --options runtime \
              --sign "Developer ID Application: Petoi LLC (H98JHTT3JH)" \
              "$ESPTOOL_PATH"
          else
            echo "Error: 未找到esptool: $ESPTOOL_PATH"
            exit 1
          fi

          # 常规签名：覆盖所有.dylib、.so和可执行文件
          find "$APP_PATH" -type f \( \
            -name "*.dylib" -o -name "*.so" -o -perm +x \
          \) -print0 | while IFS= read -r -d '' file; do
            # 跳过已处理的zip文件（内部已签名）
            if [[ "$file" != "$PYTHON_ZIP_ABSOLUTE" ]]; then
              echo "签名文件: $file"
              codesign --force --timestamp --options runtime \
                --sign "Developer ID Application: Petoi LLC (H98JHTT3JH)" \
                "$file"
            fi
          done

          # 最终签名整个.app
          codesign --force --deep --strict --options runtime \
            --sign "Developer ID Application: Petoi LLC (H98JHTT3JH)" \
            --timestamp "$APP_PATH"

      - name: Verify All Signatures
        run: |
          APP_PATH="mac/${{ github.event.inputs.app_name }}"
          RESOURCES_PATH="$APP_PATH/Contents/Resources"
          PYTHON_ZIP_ABSOLUTE="$(cd "$(dirname "$RESOURCES_PATH/lib/python37.zip")" && pwd)/$(basename "$RESOURCES_PATH/lib/python37.zip")"
          ESPTOOL_PATH="$RESOURCES_PATH/resources/esptoolMac/esptool"

          # 验证zip内文件（临时解压检查）
          if [ -f "$PYTHON_ZIP_ABSOLUTE" ]; then
            TEMP_VERIFY=$(mktemp -d)
            unzip -q "$PYTHON_ZIP_ABSOLUTE" -d "$TEMP_VERIFY"
            find "$TEMP_VERIFY" -name "*.dylib" -type f | while read -r file; do
              echo "验证zip内文件: $file"
              codesign --verify --verbose=1 "$file" || {
                echo "❌ 签名失败: $file"
                exit 1
              }
            done
            rm -rf "$TEMP_VERIFY"
          else
            echo "Error: 验证时未找到python37.zip"
            exit 1
          fi

          # 验证esptool
          codesign --verify --verbose=1 "$ESPTOOL_PATH" || {
            echo "❌ esptool签名失败"
            exit 1
          }

          # 验证整个.app
          codesign --verify --deep --verbose=4 "$APP_PATH" || {
            echo "❌ .app签名失败"
            exit 1
          }

          echo "✅ 所有签名验证通过"

      - name: Create DMG
        run: |
          mkdir -p dist/dmg
          cp -R "mac/${{ github.event.inputs.app_name }}" dist/dmg/
          ln -s /Applications dist/dmg/Applications
          
          create-dmg \
            --volname "Petoi Desktop App" \
            --background "mac/Make_for_dmg.jpg" \
            --window-pos 400 200 \
            --window-size 940 580 \
            --icon-size 100 \
            --icon "${{ github.event.inputs.app_name }}" 180 200 \
            --app-drop-link 420 200 \
            --no-internet-enable \
            "dist/Petoi_Desktop_App_${{ github.event.inputs.app_version }}.dmg" \
            "dist/dmg/"

      - name: Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PWD: ${{ secrets.APPLE_ID_PWD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          DMG_PATH="dist/Petoi_Desktop_App_${{ github.event.inputs.app_version }}.dmg"
          SUBMISSION_OUTPUT=$(xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" --password "$APPLE_ID_PWD" \
            --team-id "$APPLE_TEAM_ID" --wait --verbose 2>&1)
          echo "$SUBMISSION_OUTPUT"

          SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep -oE 'id: [0-9a-f-]+' | cut -d' ' -f2 | head -n1)
          if [ -n "$SUBMISSION_ID" ]; then
            echo "=== 公证日志 ==="
            xcrun notarytool log "$SUBMISSION_ID" \
              --apple-id "$APPLE_ID" --password "$APPLE_ID_PWD" --team-id "$APPLE_TEAM_ID"
          fi

          if ! echo "$SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
            echo "❌ 公证失败"
            exit 1
          fi

          xcrun stapler staple "$DMG_PATH"
          xcrun stapler validate "$DMG_PATH"

      - name: Final Verification
        run: |
          set -e  # 任何命令失败立即退出
          DMG_PATH="dist/Petoi_Desktop_App_${{ github.event.inputs.app_version }}.dmg"
          APP_NAME="${{ github.event.inputs.app_name }}"
          TEMP_MOUNT="/tmp/dmg_mount_$(date +%s)"  # 用时间戳避免挂载点冲突
          mkdir -p "$TEMP_MOUNT"  # 确保挂载点存在
          
          echo "验证 DMG 完整性和公证状态: $DMG_PATH"
          
          # 1. 检查 DMG 底层完整性
          hdiutil verify "$DMG_PATH" || {
            echo "❌ DMG 镜像损坏"
            exit 1
          }
          
          # 2. 验证 DMG 公证凭证
          xcrun stapler validate "$DMG_PATH" || {
            echo "❌ DMG 公证凭证无效"
            exit 1
          }
          
          # 3. 挂载 DMG 并捕获实际挂载点（处理可能的多卷/自动路径）
          echo "挂载 DMG 到临时目录: $TEMP_MOUNT"
          # 用 -mountpoint 强制指定挂载点，确保路径可控
          hdiutil attach "$DMG_PATH" -mountpoint "$TEMP_MOUNT" -readonly -nobrowse -quiet || {
            echo "❌ 挂载 DMG 失败"
            exit 1
          }
          
          # 调试：列出挂载点内容，确认 App 实际路径（关键！）
          echo "=== 挂载点内容列表 ==="
          ls -la "$TEMP_MOUNT"
          echo "======================"
          
          # 4. 定位 DMG 内的 App（处理空格路径，必须用双引号包裹）
          APP_IN_DMG="$TEMP_MOUNT/$APP_NAME"
          # 强制转义路径中的特殊字符（处理空格、括号等）
          APP_IN_DMG_ESCAPED=$(printf "%q" "$APP_IN_DMG")
          
          # 检查 App 是否存在（带详细错误信息）
          if [ ! -d "$APP_IN_DMG" ]; then
            echo "❌ DMG 内未找到 App！预期路径：$APP_IN_DMG"
            echo "请检查 DMG 内实际文件结构（见上方挂载点内容列表）"
            hdiutil detach "$TEMP_MOUNT" -quiet || true
            exit 1
          fi
          
          # 6. 验证 App 公证状态
          echo "验证 DMG 内 App 的公证状态"
          spctl -a -vvv -t install "$APP_IN_DMG" || {
            echo "❌ App 公证状态验证失败: $APP_IN_DMG"
            hdiutil detach "$TEMP_MOUNT" -quiet || true
            exit 1
          }
          
          # 7. 卸载 DMG
          hdiutil detach "$TEMP_MOUNT" -quiet || {
            echo "⚠️ 卸载 DMG 失败，尝试强制卸载"
            hdiutil detach "$TEMP_MOUNT" -force -quiet || true
            exit 1
          }
          
          echo "✅ 所有验证通过（DMG 完整性 + 内部 App 签名 + 公证状态）"

      - name: Upload DMG
        uses: actions/upload-artifact@v4
        with:
          name: Petoi_Desktop_App_${{ github.event.inputs.app_version }}.dmg
          path: dist/Petoi_Desktop_App_${{ github.event.inputs.app_version }}.dmg
          retention-days: 30
